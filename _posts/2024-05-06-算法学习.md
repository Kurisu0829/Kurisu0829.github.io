---
title: 算法学习
date: 2024-05-06 22:06:00 +0800
categories: [学习, 算法]
tags: [算法]
---

# 数组
## 二分查找
问题：到底是 while(left < right) 还是 while(left <= right)，到底是right = middle呢，还是要right = middle - 1呢？  

写二分法，区间的定义一般为两种，**左闭右闭即[left, right]，或者左闭右开即[left, right)**。区间的定义这就决定了二分法的代码应该如何写。区间的定义就是不变量，要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。

1. **写法一[left, right]**
- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
1. **写法二[left, right)**
- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]  
- left不管哪种写法都是mid + 1

代码示例：
```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] > target)
                right = mid - 1;
            else if(nums[mid] < target)
                left = mid + 1;
            else
                return mid;
        }
        return -1;
    }
}
```

## 双指针法  
问题：移除数组元素，数组中的元素无法单纯删除，只能覆盖。  

1. **暴力解法**  
两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组，一层循环找到目标值元素后，第二次循环依次将后面所有元素向前移动一个位置，并将最后的元素覆盖为目标值，时间复杂度较高。
2. **双指针**  
通过一个快指针和慢指针在一个for循环下完成两个for循环的工作，很多考察数组、链表、字符串等操作的面试题，都使用**双指针法**，要明确快慢指针各自的含义！  
- 快指针：寻找新数组的元素，新数组就是不含有目标元素的数组
- 慢指针：指向更新新数组下标的位置
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 快慢指针
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```

问题：给一个按非递减顺序排序的整数数组nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序，该问题关键在于正负数平方后大小关系可能会发生改变。
1. **暴力解法**  
先全部平方覆盖，在对数组做整体排序。时间复杂度是 O(n + nlogn)
2. **双指针法**  
要点在于数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法，i指向起始位置，j指向终止位置，同时定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置，将左右两边最大数填入新数组。
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int right = nums.length - 1;
        int left = 0;
        int[] result = new int[nums.length];
        int index = result.length - 1;
        while (left <= right) {
            if (nums[left] * nums[left] > nums[right] * nums[right]) {
                // 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置
                result[index--] = nums[left] * nums[left];
                ++left;
            } else {
                result[index--] = nums[right] * nums[right];
                --right;
            }
        }
        return result;
    }
}
```

## 滑动窗口  
在力扣上看到一个代码模板，可能很有参考价值。

```c
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```
其中两处 ... 表示的更新窗口数据的地方，直接往里面填就行了。


# 链表
# 哈希表
# 字符串
# 双指针

