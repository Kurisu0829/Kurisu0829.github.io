---
title: 计网学习
date: 2024-07-11 15:17:00 +0800
categories: [学习, 计网]
tags: [计网]
---

主要做一个大纲，尽量口语化供日后复习检验，详细内容还是在小林Coding上查看。

## 一. TCP/IP网络模型和OSI网络模型
### TCP/IP模型
1. 应用层  
* 用户直接接触到的层次，提供网络与应用交互的接口，通过各种应用层协议为应用提供服务，比如HTTP、FTP、SMTP。
2. 传输层  
* 为应用层提供网络支撑，承接着应用层数据的收发。
* 有TCP、UDP两个协议，TCP相比UDP更加可靠，提供了流量控制、超时重传、拥塞控制等功能，而UDP只负责数据发出，不保证是否能抵达目标方，当然效率会因此变高。
3. 网络层  
* 使用IP对设备进行编号，通过IP寻址找到目标设备，通过路由找到前往目标的路径。
4. 网络接口层  
* 网络接口层主要为网络层提供「链路级别」传输的服务，IP无法在以太网中识别设备，因此需要MAC地址标识设备，通过ARP等协议由IP获取目标MAC地址，实现数据在以太网的传输。

### OSI模型
1. 应用层
* 网络与应用交互的接口，通过各种应用层协议为应用提供网络服务。
2. 表示层
* 负责数据格式的转换以及加密解密，确保数据的正确解释和呈现。
3. 会话层
* 负责管理应⽤程序之间的会话连接，包括创建、维护以及终止。（应用层+表示层+会话层与TCP/IP模型的应用层相似）
4. 传输层
* 提供应用到应用的数据传输服务，承接应用层数据的收发。（与TCP/IP模型的传输层相似）
5. 网络层
* 负责数据的路由和转发。（与TCP/IP模型的网络层相似）
6. 数据链路层
* 建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能，以MAC地址访问介质。
7. 物理层
* 负责物理传输媒介的传输，进行电信号和数字信号之间的转换。（数据链路层+物理层与TCP/IP模型的网络接口层相似）

## 二. 从输入URL到页面显示经历了什么
### HTTP
1. 解析URL，URL组成为：协议//Web服务器/目录名/...... /文件名，比如https://bilibili.com/blackborad/activity-list.html
2. 根据解析出来的信息生成HTTP请求信息。

### DNS
1. 域名的层级关系  
* 根DNS服务器（.）
* 顶级域DNS服务器（.com）
* 权威DNS服务器（server.com）
2. 域名解析流程  
* 询问本地DNS服务器，查询缓存。
* 询问根DNS服务器，根DNS服务器给出.com的地址。
* 询问.com顶级域DNS服务器，顶级域DNS服务器给出server.com权威DNS服务器的地址。
* 询问server.com权威DNS服务器，给出目标IP。
3. 迭代查询和递归查询
* 迭代查询里，客户端向上层DNS服务器发起查询请求，其只是询问一个更高级的DNS服务器的地址，再向该更高级服务器发起请求，直到获取完整的解析结果。
* 递归查询，客户端向上层DNS服务器发起查询请求，等待服务器返回完整结果，上层服务器会自动查询下一级服务器，并最终返回结果。

### 协议栈
1. 应用程序通过Socket库，委托操作系统中的协议栈工作。
2. 协议栈上半是负责收发数据的TCP和UDP协议，下半是控制网络包收发的IP协议，再由网卡驱动控制网卡完成链路层面的收发。

### TCP
1. 由于HTTP是基于TCP传输的，于是应用程序会委托操作系统调用协议栈中的TCP协议。
2. 在HTTP使用TCP传输数据前，首先需要通过三次握手建立连接，保证双方都有发送和接收的能力。   
3. 若HTTP请求消息过长，需要分割数据。  
4. 根据TCP包头结构需要，加上TCP头部，生成TCP报文，内容涉及源端口号和目标端口号、包的序号、确认号、状态位、窗口大小。  

### IP
1. TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成网络包发送给通信对象。
2. 根据IP包头格式，加上IP头部，生成IP报文，内容涉及源地址IP和目标地址IP、上层传输协议号。
3. 存在多块网卡需要根据路由表判断源地址IP是哪一个网卡的。  

### MAC
1. MAC地址是以太网使用的头部，前面网络分层模型有提到过。
2. 确认发送方接收方，通过ARP协议获取接收方的MAC地址。
3. 加上MAC头部，生成MAC报文，内容包括接收方MAC地址、发送方MAC地址、协议类型。

### 网卡
1. 负责数字信号和电信号之间的转换。
2. 网卡驱动获取网络包之后，会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列，转换为电信号发出去。

### 交换机
1. 交换机接收数据包，将电信号变为数字信号，一般来说收到包的设备会核对包头的接收方MAC地址是否为自己，不是则丢弃，但对于交换机来讲他本身没有MAC地址，他会去查询MAC地址表，发送包到对应端口上。
2. MAC不存在则会转发到除了源端口的所有端口上，并在MAC地址表上进行记录。

### 路由器
1. 路由器与交换机不同的是，路由器各个端口都是有MAC地址和IP地址的，其可以作为包的发送方和接收方。
2. 路由器会接受发送给自己的包，丢弃MAC地址不匹配的包。
3. 路由表接收包后，去除MAC头部，路由器会根据后方的IP头部中的内容，查询路由表确定转发目标
4. 是否到达终点以路由表网关为准，如果网关是一个IP地址，则还未抵达终点，还需继续需要路由器转发。如果网关为空，也是就终于找到IP包头里的目标地址了，说明已抵达终点。会继续通过ARP协议根据IP查询MAC地址，再通过端口发送出去，层层转发。

### 服务器与客户端
1. 服务器收到报文，扒开MAC头部，检查是否和自己的MAC地址相符。
2. 扒开IP头部，发现IP地址相符，上层协议是TCP。
3. 扒开TCP头部，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个ACK。TCP头部里面还有端口号，HTTP的服务器正在监听这个端口号。
4. 于是服务器将网页内容封装在HTTP响应报文中，以同样的流程发送回客户端。
5. 客户端收到报文也开始扒开头部，把收到的数据包的皮扒剩HTTP响应报文后，交给浏览器去渲染页面，网页就显示出来了。
6. 四次挥手断开TCP连接。

## 三. HTTP请求报文和响应报文是怎样的
### 请求报文
其主要由请求⾏、请求头、请求体构成。
1. 请求行
* 请求⽅法： GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE
* URL： <协议>：//<主机>：<端⼝>/<路径>?<参数>
* 协议版本号： HTTP版本号
2. 请求头  
包含请求的附加信息：
* Host：指定服务器的主机名和端⼝号。
* User-Agent：标识客户端的⽤户代理（浏览器或其他⼯具）。
* Accept：指定客户端可以接受的响应的MIME类型。
* Content-Type：指定请求主体的MIME类型。
* Authorization：⽤于进⾏身份验证的凭据。
3. 请求体
* 承载多个请求参数的数据, 请求体是可选的，通常在发送POST、PUT等请求时包含请求的实际数据。
### 响应报文
HTTP响应报⽂是服务器向客户端返回的数据格式，通常包含状态⾏、响应头、响应体。
1. 状态行
* HTTP协议版本（通常是"HTTP/1.1"）
* 状态码（表示服务器处理结果的三位数字代码）
* 状态消息（对状态码的简要描述）
2. 响应头
* Content-Type：指定响应主体的MIME类型。
* Content-Length：指定响应主体的⻓度（字节数）。
* Server：指定服务器的信息。
* Location：在重定向时指定新的资源位置。
* Set-Cookie：在响应中设置Cookie。
3. 响应体
* 响应主体包含服务器返回给客户端的实际数据。

## 四. HTTP请求方式有哪些
1. GET：申请获取资源，不对服务器产⽣影响。
2. POST：POST请求通常⽤于发送数据，例如提交表单数据、上传⽂件等，会影响服务器，服务器可能动态创建新的资源或更新原有资源。
3. HEAD：类似GET，仅要求服务器返回头部信息，不返回实际的资源内容。
4. PUT：⽤于更新服务器上的资源或创建新资源。
5. DELETE：请求服务器删除指定的资源。
6. TRACE：⽤于测试。要求⽬标服务器返回原始的HTTP请求内容。
7. PATCH： ⽤于对资源进⾏部分更新。
8. CONNECT：⽤于代理服务器。
9. OPTIONS：⽤于获取服务器⽀持的HTTP⽅法列表，以及针对指定资源⽀持的⽅法。

## 五. GET请求和POST请求有哪些区别
1. 语义
* 按照规范，GET的语义是从服务器获取指定资源。
* 按照规范，POST的语义是根据请求负荷（报文body）对指定的资源做出处理。
* 两种请求一个不会对服务器资源做出修改，一个会对服务器资源作出修改。
2. 参数
* 按照规范，GET请求的参数位置一般是写在URL中，URL规定只能支持ASCII，所以GET请求的参数只允许ASCII字符 ，而且浏览器会对URL的长度有限制。
* POST请求携带数据的位置一般是写在报文body中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对body大小做限制。
* 但实际上任何请求都可以带body，POST请求的URL中也可以有参数，只是按照规范定义来讲是不行的。

## 六. HTTP常见状态码
1. 1xx：提示信息，表示正在HTTP请求处理的中间态。
2. 2xx：服务器成功处理了客户端的请求。
3. 3xx：客户端请求的资源发生了变动，重定向。
4. 4xx：服务端无法处理客户端发送的报文。
5. 5xx：客户端报文正确，服务器处理时内部出现了问题。

## 七. 什么是强制缓存和协商缓存
### 强制缓存
1. 概念：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存。
2. 实现方式：通过响应头部的Cache-Control或是Expires字段来实现，区别在于前者是相对时间，后者是绝对时间，Cache-Control的优先级高于Expires，选项设置更加精细多样。
### 协商缓存
协商缓存是在Cache-Control已过期的情况下才考虑的。
1. 概念：通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存，即使Cache-Control已过期，服务器告诉客户端你可以继续使用这个缓存。
2. 实现方式：
* 请求头部中的If-Modified-Since字段与响应头部中的Last-Modified字段实现，响应头部返回Last-Modified即资源最后被修改的时间，缓存过期后下一次发出请求时在头部If-Modified-Since字段带上该时间，与服务器资源现在的最后被修改时间进行比较，若服务器资源较新，返回最新资源，反之则走304状态码继续使用缓存。
* 请求头部中的If-None-Match字段与响应头部中的ETag字段实现，当资源过期时，浏览器发现响应头里有Etag，则再次向服务器发起请求时，会将请求头If-None-Match值设置为Etag的值。服务器收到请求后进行比对，如果资源没有变化返回304，如果资源变化了返回200。

## 八. HTTP1.0和HTTP1.1区别
1. HTTP1.1使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销
2. 支持管道网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

## 九. HTTP2.0和HTTP1.1区别
* 头部压缩
* 二进制格式
* 并发传输
* 服务器主动推送资源
* 缺陷

## 十. HTTP3.0
* UDP & QUIC
* 无队头阻塞
* 更快的连接建立
* 连接迁移

## 十一. HTTP和HTTPS区别
* 安全协议
* 连接建立
* 默认端口
* 数字证书

## 十二. HTTPS工作原理
* 混合加密
* 摘要算法
* 数字证书
* 连接建立
* 数据完整性    

## 十三. TCP和UDP的区别

## 十四. TCP如何确保连接可靠性
### 重传机制
* 超时重传
* 快速重传
* SACK
* D-SACK
### 滑动窗口
* 发送窗口
* 接收窗口
### 流量控制
* 操作系统缓冲区
* 窗口关闭
* 糊涂窗口综合症
### 拥塞控制
* 慢启动
* 拥塞避免
* 拥塞发生
* 快速恢复

## 十五. UDP怎么实现可靠传输
* Packet Header
* QUIC Frame Header
* 队头阻塞
* 流量控制
* 连接建立
* 迁移连接 

## 十六. 三次握手过程 & 为什么是三次？

## 十七. 四次挥手过程 & 为什么是四次？

## 十八. HTTP的Keep-Alive是什么？它和TCP的Keepalive是一个东西吗？

## 十九. CDN是什么

## 二十. Cookie和Session是什么，有什么区别