## 第一周学习
### 7.21学习
Docker方面自己以前在部署AutoBangumi这个项目的时候接触过，也是在文档和朋友的帮助下成功的跑了起来，只知道按照他给的配置文件和命令一顿操作，对其是知其然而不知其所以然，为此需要进行更加系统的学习。  
首先是了解了Docker最基本的三元素——**镜像、容器、仓库**，Docker本身只是一个容器的运行载体，而镜像是容器的模板，容器示例由Docker通过镜像文件创建，一个容器运行一种服务，一个镜像可以包含多个容器，仓库则是存放各种镜像的地方。  
在WSL上安装好了docker-ce，配置了阿里云镜像站的stable仓库，在docker run hello-world时遇到了**context deadline exceeded**报错的问题，总之就是镜像拉不下来，想起来早在去年六七月份国内的docker容器镜像站大多已经停用，包括阿里云容器仓库的加速器也已经只对云服务器用户开放使用了，我打算用在WSL中配置网络代理的方式来解决。得知Clash For Windows也可以在Linux上运行，我尝试了在WSL上装CFW，配完后发现图形界面并不像Windows上的有系统代理按钮，改用Clash的Linux版本，发现还是不行，一查发现WSL和主机网络是互通的，由于NAT代理IP配127.0.0.1是不会有效果的，最后成功连上代理后却发现命令行仍然是走不了代理的，在<strong>/etc/docker/daemon.json</strong>中配置代理IP后终于成功拉取下来了run hello-world所需的镜像。  
### 7.22学习
昨天主要是由于大陆网络的特殊情况被困扰了许久，现在Docker上这些问题已经成功得到了解决。拉取镜像的折磨不禁让我想起Spring中依赖下载的痛苦，经常下载失败而又莫名其妙的全部下载完了，今天强化SpringBoot的学习中我也想把这个疑难杂症一并解决了。  

SpringBoot的构建过程主要包括：
1. 创建Maven项目  
2. 导入SpringBoot起步依赖  
最基本的就是继承**spring-boot-starter-parent**父工程，以及引入服务对应的**spring-boot-starter-xxx**依赖，比如spring-boot-starter-web依赖，是web开发的起步依赖。这里涉及到很重要的问题就是插件和依赖从maven仓库里也和docker一样很难拉下来，给IDEA配置好了代理，连接测试通过，但maven此时不会正常走代理，大概又要去单独配置了。最后在所使用的maven文件夹下的settings.xml中配置proxies相关内容即可，同时我还配置了阿里云的镜像仓库，更加方便，经测试能够成功连接上阿里云的仓库。  
父工程中包含版本锁定，约定了各种技术依赖的版本，这样在pom文件引入依赖时就不再需要编写版本信息了，也能保证所使用的各种依赖之间不会发生冲突。同时依赖是可以传递的，诸如spring-boot-starter-web，其本身也是基于多条依赖的，但在项目中引入时，我们可以只需要引入web起步依赖就可以了。
3. 定义Controller  
4. 编写引导类  
引导类是SpringBoot项目的入口，运行main方法就可以启动项目，主要特征是以**Application**结尾。
5. 启动测试  

SpringBoot配置文件：
1. SpringBoot是基于约定的，很多配置都是有默认值的，分为properties和yml两类，properties是键值对样式的，比如server.port = 8080; yml是冒号表示且子条目是带缩进的。
2. yml有对象、数组、纯量三种数据格式。对象就是分行缩进冒号表示的键值对，行内写法需要带大括号；数组，分行使用横杠<strong>-</strong>表示，行内写法需用中括号；纯良就是常量。参数引用采用<strong>${name}</strong>的方式。
3. 配置文件中的值可通过<strong>@Value注解、Environment类、@ConfigurationProperties注解</strong>来获取。@Value注解主要结合${name}来使用；Environment类通过@Autowired注入对象后，调用getProperty方法获取特定属性的值；@ConfigurationProperties结合@Component注解使用，标注在获取配置数据的实体类上。
4. profile，profile文件是用于配置多套环境的，对不同环境的同一套参数，可以通过**spring.config.active.on-profile**标记名称，再用**spring.profiles.active**来激活不同的参数。此外还可以通过虚拟机启动参数、命令行参数来激活，命令行参数同样适用于直接运行jar包。
5. 内部配置文件优先级从高到底为项目根目录/config下的、项目根目录下的、classpath/config下的、class目录下的，高优先级会覆盖低优先级的配置。外部配置优先级常用方法从高到底为命令行、外部配置文件等。
6. Junit的引入，用以编写单体测试。主要基于**spring-boot-starter-test**以及**junit**两个依赖，针对服务类进行测试，在测试类前使用<strong>@Runwith</strong>以及<strong>@SpringBootTest</strong>两个注解，自动注入服务类对象，在测试方法中调用要测试的服务类方法，注意测试方法前要用<strong>@Test</strong>注释标注。
7. Redis的引入  
（环境待配置）
1. MyBatis的引入  
主要导入**mybatis-spring-boot-starter**和**mysql-connector-j**两个依赖，除了在yml文件里配置数据源外，还需要构建实体类目录以及映射类目录，比如常见的domain和mapper，需要注意<strong>@Mapper</strong>以及<strong>@Repository</strong>两个注解的使用，如果是采用Mapper接口+XML文件的方式完成SQL查询任务的话，配置文件里还需要配置mapper映射文件路径以及实体包名。

### 7.23学习
昨天已经基本走过了SpringBoot项目的搭建、配置以及第三方技术的引入这样的流程，今天主要是对相关原理进行学习。  

SpringBoot自动配置原理： 
1. Condition功能   
构建项目时我们需要思考一点，SpringBoot是怎么知道要创建哪个Bean的？他怎么知道依赖有没有被导入呢？  
这些主要是依赖Condition功能来实现的，Condition是Spring4.0增加的条件判断功能，通过这个功能可以实现选择性的Bean创建操作，可以为是否创建Bean提供条件判断前提，实际中SpringBoot提供了<strong>@ConditionOnClass</strong>等注解来实现动态的条件判断。
2. Enable  
SpringBoot提供了很多Enable开头的注解，这些注解都是用于动态启用某些功能的，其底层原理是通过<strong>@Import</strong>注解导入一些配置类，实现Bean的动态加载，如果想要获取的一个类不在同一个包下，就必须使用Enable来启用，可以使用<strong>@ComponentScan</strong>指定包名，@Import指定类名，但这种方式较为不灵活，我们可以自定义Enable注解，这样在之后使用的时候只需要标注注解就可以实现Bean的加载了。  
<strong>@Import</strong>注解可以用来导入Bean、导入配置类、导入ImportSelector实现类，一般用于加载配置文件中的类、导入ImportBeanDefinitionRegister实现类。  
<strong>@EnableAutoConfiguration</strong>内部使用@Import(AutoConfigurationImportSelector.class)来加载配置类，配置文件位于**META-INF/spring.factories**，该配置文件中定义了大量的配置类，当SpringBoot应用启动时，会自动加载这些配置类，初始化Bean，在配置类中使用Condition来控制哪些Bean被初始化。  
3. 自定义starter  
SpringBoot提供的启动类已经非常完善，这一步主要是帮助我们能够更好地了解整个SpringBoot自动配置的原理。以自定义redis-starter为例，分为三步：  
创建redis-spring-boot-autoconfiguration模块；创建redis-spring-boot-starter模块，依赖于redis-spring-boot-autoconfiguration；在redis-spring-boot-autoconfiguration中初始化Jedis的Bean，定义META-INF/spring.factories文件。创建完毕后我们在测试模块中引入自定义的redis-starter依赖，测试是否能获取到Jedis的Bean。  

SpringBoot监听：  
我们可以实现监听器接口，在项目启动完成时进行一些操作。  
1. ApplicationContextInitializer，需要在/META-INF/spring.factories中配置，用于IOC容器还没准备好之前检测一些资源是否存在。
2. SpringApplicationRunListener，涵盖了项目全生命周期的方法，需要在/META-INF/spring.factories中配置，还需要给实现类编写构造方法。
3. CommandLineRunner和ApplicationRunner，两者都是在项目启动后执行重写的run方法，不需要进行配置，启动项目自动运行，可以用来做缓存预热，一般只选一个来用。  

SpringBoot项目的构建流程和一些基本的原理就到这里了，对于细节的把控还是需要通过自己从0写一个项目来进行，想去挑一个感兴趣又实用的项目进行学习，但到现在也还没想好应该往哪方面靠。

### 7.24学习  
后续进行Docker的学习，前期已经配置好了各种环境，扫清了网络等障碍，苦于不同设备反复配置Java、Python、Mysql、Redis等环境，我在想能不能通过Docker来为我后续个人项目的开展制定一套统一的环境。（疑问：WSL里的环境要怎么和主机开发配合呢，网络互通所以直接连吗，到时候试一试）  

Docker容器常用命令：
1. <strong>docker run [OPTIONS] IMAGE [COMMAND][ARG...]</strong>  
运行创建新容器，常用OPTIONS包括<strong>--name</strong>（为容器指定一个名称）、<strong>-i</strong>（交互模式运行容器），<strong>-t</strong>（为容器重新分配一个伪输入终端），这两者通常一并使用，所谓交互就是等待用户命令、<strong>-P</strong>（随机分配端口映射），<strong>-p</strong>（指定端口映射），以<strong>-p 8080:80</strong>为例，就是把容器内服务应用程序端口映射到宿主机端口，两者进行映射才能实现容器与外界进行通信、<strong>-</strong>
2. **docker ps**  
列出所有容器，常用OPTIONS有-a（列出当前正在运行的和历史上运行过的容器）、-l（显示最近创建的容器）、-n（显示最近n个创建的容器）、  -q（只显示容器编号）
3. 容器启停相关  
容器有两种退出方式，**exit**以及**ctrl+p+q**，前者容器停止，后者容器不停止。启动已停止的容器**docker start 容器ID或容器名**、重启容器**docker restart 容器ID或容器名**、停止容器**docker stop 容器ID或容器名**、强制停止容器**docker kill 容器ID或容器名**、删除已停止的容器**docker rm 容器ID**
4. 容器重要命令  
启动守护式容器（后台服务器），我们可以通过-d指定容器的后台运行模式，诸如Redis、Mysql，都应该是这种方式。需要注意的是**Docker容器后台运行，必须有一个前台进程**，容器运行的命令如果不是那些一直挂起的命令，是会自动退出的，比如对于ubuntu、centos、nginx这些容器，他们后台启动的话会认为自己没事可做于是就自杀了，只能以-it来运行。  
对于容器进行监测管理还有查看容器日志**docker logs 容器ID或容器名**、查看容器内运行进程**docker top 容器ID或容器名**、查看容器内部细节**docker inspect 容器ID或容器名**。  
想要重新进入正在运行的容器，可以通过**docker exec -it 容器ID bashShell**命令和**docker attach 容器ID**两种命令，attach直接进入容器启动命令的终端，不会启动新的进程，exit会导致容器的停止；而exec是在容器中打开新的终端，并且可以启动新的进程，exit不会导致容器的停止。更为推荐使用exec命令。
5. 容器文件拷贝和导入导出  
容器文件拷贝**docker cp 容器ID:容器内路径 目的主机路径**，容器导出**docker export 容器ID > tar文件名**，容器导入**cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号**

镜像进阶：  
1. Docker中镜像是从base镜像一层一层叠加生成的。当容器启动时，一个新的可写层将被加载到镜像的顶部，这一层通常被称为容器层，容器层之下的都叫镜像层，所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。
2. Docker Hub中拉取的Ubuntu镜像是轻量级的，只包含了必要核心功能，以vim为例，是不支持该命令的。我们在拉取的镜像中安装vim，再通过<strong>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[tag]</strong>命令生成新的镜像，那么这个镜像就相当于是升级版的Ubuntu了。
3. 镜像上传阿里云在阿里云官网有一套完整的命令和说明，后续个人项目的环境就打算配置一套在阿里云上，对于私有库的搭建主要是了解相关的使用方法和常规配置仓库有没有什么区别，因为后续在工作中接触的Docker相关大概也是自建私有库进行存储的。
4. 卷就是目录或者文件，容器数据卷就是将容器目录和主机目录做映射，将容器中的重要数据备份+持久化到本地主机目录。数据卷能够绕过Union File System提供一些持续存储或共享数据的特性，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。  
要给运行的容器挂载数据卷，需要通过<strong>--privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</strong>这样的OPTIONS来挂载。加上ro的话容器自己只能读不能写，但宿主机的修改可以同步到容器。
5. Docker中服务安装基本就是拉取镜像并运行容器的过程，但之中会出现例如tomcat目录下webapps为空，而运行所需实际内容变更到了webapps.list文件夹这中问题，需要我们手动进行修改。  
而Mysql安装出现的问题就是Docker上默认字符集编码不支持我们对中文数据进行操作，且若是要对Mysql容器进行删除，我们在实际运行容器时要挂载<strong>/log、/data、/conf</strong>的容器数据卷以保证数据不丢失。挂载好后在/conf下创建my.cnf配置UTF8字符集后即可正常处理中文数据。Redis容器同样也面临着这样的问题，因此要挂载数据卷后配置redis.conf。

## 第二周学习
直接上手SpringBoot项目总会感觉有些似懂非懂，就是我做不到就凭自己的思考就能知道这个地方该用哪些注解，该配置哪些东西，趁这个机会把基础打牢固，主要围绕WEB基础包括SQL、JDBC等。
### 7.28学习
SQL语句：  
1. 分为四类，DDL数据定义语言，用来定义数据库对象比如数据库、表等；DML数据操作语言，用来对数据库的表中数据进行增删改；DQL数据查询语言；DCL数据控制语言，用来定义数据库的访问权限和安全级别。
2. DML中update语句没有加where条件的话会将表中的数据全部修改，需要注意，delete语句也是一样。
3. DQL最为常用，根据不同的关键词可以分为基础、条件、排序、聚合、分组、分页查询。

### 7.29学习
数据库：  
1. 一对多表关系，需要在多的一方建立外键，指向另一方的主键；多对多表关系，建立第三张中间表，表中包含至少两个外键，分别关联两方主键；一对一表关系在任意一方加入外键关联另一方主键即可。
2. 内连接就是取交集，外连接就是交集加上一部分独有的，分为左右外连接。以前一直对这个概念不是很清楚，还记得数据库的课上都是在训练不使用内连接外连接的隐式写法，只允许用最基本的关键字来写各种复杂SQL，当时被搞的头很大。

Maven:  
1. 坐标是Maven中资源的唯一标识，由定义当前Maven项目隶属组织的groupId、定义当前项目名称的artifactId、version版本号组成。
2. 坐标的依赖范围对应了jar包的作用范围：编译环境、测试环境、运行环境。一般导入坐标的时候不设置scope都可以，这是因为会默认设置作用范围全包含的compile。  
其他的范围包括test仅包括测试环境、provided不包括运行环境、runtime不包括编译环境、system不包括运行环境。

MyBatis：  
1. 是为了简化传统的JDBC开发，JDBC存在着硬编码且操作繁琐的缺点，MyBatis通过配置文件和自动完成结果封装等操作过程来进行简化开发。
2. 值得注意的是只有采用驼峰命名法才能让数据库表的字段名称和实体类的属性名称映射上，从而自动封装数据。我们可以通过在SQL语句中起别名来映射，但这种方式一旦涉及到的字段多起来操作会很麻烦。  
我们还可以使用**resultMap**来实现映射，这种方式是最为主流的，在resultMap中我们可以定义好数据库表的字段名称和实体类的属性名称的映射，在编写SQL语句时直接标注resultMap替换resultType即可。
3. 传参时要采用<strong>#{id}</strong>的方式来进行，其原理是在sql语句中先将参数替换为?再赋值进去，而${id}是拼接sql，会出现sql注入的问题。
4. 在xml里特殊字符处理可以采用转义字符、CDATA区的方式来处理。特殊字符少用转义字符方便，特殊字符要处理的多用CDATA区更好。
5. 多条件查询，and连接各个条件即可，对象传参要注意对象属性名称和参数占位符的名称一致。
6. 条件不会是每一次查询都是固定的，用户可能会只限定某几个条件进行查询，MyBatis对动态sql提供了强大的支撑。  
可以通过if标签编写条件判断逻辑动态修改sql语句，对于第一个条件不需要and运算符的问题，可以在开头加入恒等式统一格式，也可以将where改用where标签。  
choose(when, otherwise)标签类似于switch语句，也可以实现相同的效果。这之中otherwise主要是保证一个条件都没有的时候sql语句不会出错，where标签可以起到同样的作用。
7. 如果想要插入数据后返回主键信息，在insert标签中添加<strong>useGeneratedKeys="true" keyProperty="id"</strong>就可以将id作为返回值了。对于动态属性的修改也同样是采用动态sql来实现。
8. 删除主要使用foreach标签，MyBatis会将数组参数封装为一个Map集合，默认键为array，在foreach标签中遍历需要指定集合名称，要么使用array，要么用@Param注解改变Map集合的默认key的名称。
9. 在传参中单个POJO类型、Map类型数据直接保证属性名和键名和参数占位符名称一致即可，集合类型同样会被封装默认键:集合的Map。多个参数会被封装为Map集合，可以使用默认键名arg，更推荐通过<strong>@Param</strong>注解改变Map集合的默认key的名称。

### 7.30学习
Web核心：  
1. Servlet运行在Web服务器中，默认情况下，当Servlet第一次被访问时，容器创建Servlet对象；在Servlet实例化后，容器将调用init()方法初始化这个对象，完成一些加载配置文件、创建连接等初始化工作；每次请求Servlet时，容器都会通过调用service()方法对请求进行处理；当要释放内存或关闭容器时，容器就会调用destroy()方法完成资源的释放，被Java垃圾回收。

会话跟踪：  
1. 是为了实现同一会话多次请求和响应的数据共享。Cookie是在客户端方面的跟踪技术，Session则是在服务端的会话跟踪技术。
2. Cookie是将数据保存到客户端，以后每次请求都携带Cookie数据进行访问。是由服务端创建Cookie对象并使用response对象发送至客户端供客户端使用的。
3. Cookie的实现是基于HTTP协议的，通过响应头set-cookie和请求头cookie实现。
4. 默认情况下Cookie存储在浏览器内存中，浏览器关闭，内存释放，Cookie销毁。但也可以通过<strong>setMaxAge(int seconds)</strong>方法设置存活时间。
5. Cookie不能直接存储中文，如需存储需要使用URL编码进行转码。
6. Session在服务端存储数据并获取，JavaEE提供了HttpSession类来实现对应功能。
7. Session是基于Cookie实现的，是通过Cookie传递JSESSIONID来确保同一会话中每次获取的Session是相同的，但不同会话中是不同的。

### 7.31学习
Filter、Listener：  
1. 过滤器可以把对资源的请求拦截下来。过滤器的使用流程主要包括定义类，实现Filter接口，重写其所有方法；配置Filter拦截资源的路径，在类上定义<strong>@WebFilter</strong>注解；在**doFilter**方法中放行。
2. 可以配置多个过滤器形成过滤器链。注意是先依次执行放行前逻辑并放行，全部完毕后再依次执行放行后逻辑。
3. Listener和之前提到的SpringBoot监视器一样，都是监听特定对象创建、销毁、修改时自动执行代码的功能。

Spring：  
1. Bean的实例化可以依靠无参的构造方法，自定义无参方法或者不写使用默认构造方法都可以，若自定义有参构造方法会初始化失败。  
Bean的实例化还可以使用静态工厂，其实也就是另创一个类返回该类new出的对象，使用面主要是兼容老旧代码。  
最后就是动态工厂，这个方法就是工厂本身也作为Bean被IOC容器管理，实际配置起来相比于第一种方法显得没什么意义，于是还可以实现**FactoryBean**类，重写其**getObject和getObjectType**方法从而得到简化配置。
2. Bean生命周期包含初始化容器、使用Bean、关闭销毁容器三个大的阶段，初始化中依照创建对象（分配内存）、执行构造方法、执行属性注入、执行Bean初始化方法的步骤来进行。  
Bean生命周期中的destory方法，必须得在关闭容器前才能运行，可以通过ClassPathApplicationContext中的close方法暴力关闭，更推荐使用**registerShutdownHook**注册关闭钩子再用close方法关闭更为推荐。  
3. 依赖注入可以通过setter注入（set方法）和构造方法，要分别考虑对简单类型的注入和引用类型的注入。主要使用方法就是在bean中定义引用类型属性，提供可访问的set方法，再在配置中使用**property**标签**ref**属性引入引用类型对象，使用**value**属性引入简单数据类型。  
构造器同理就是通过构造方法来注入，用**constructor-arg**标签ref属性注入引用类型对象，value属性注入简单数据类型，对于简单数据类型构造器传参由于是形参直接使用name属性会有问题，可以用代表形参类型的**type**属性和形参位置的**index**属性按形参位置注入。

### 8.1学习
Spring注解开发：  
1. @Component注解和三个衍生注解@Service、@Repository、@Controller都是一个作用，即取代了手动通过Bean标签配置文件中配置Bean的过程。
2. @Configuration注解取代了配置文件中初始的配置文本，使得我们可以通过配置类替代配置文件，@ComponetScan指定了扫描Bean的路径。
3. @AutoWired针对同名bean需要通过@Qualifier注解开启指定名称装配bean，一般不需要，@Value实现简单数据类型注入，@PropertySource加载外部配置文件，从而使Value注解能够直接通过属性名读取值。

### 8.4学习
AOP：
1. 为了在不惊动原始设计的基础上为其进行功能增强。在连接点的切入点上执行通知类定义的通知方法，切面就是切入点和通知之间的关系。
2. 基本使用流程为导入AOP相关坐标 -> 定义Dao和实现类 -> 定义通知类 -> 定义切入点 -> 绑定切入点和通知关系，并指定通知添加到连接点的具体执行位置 -> 定义通知类受Spring容器管理，并定义当前类为切面类。
3. 切入点表达式可以使用通配符快速描述。"*"是单个独立的任意符号，可以独立出现，也可作为前后缀匹配符出现。".."是多个连续的任意符号，常用于简化包名与参数的书写。"+"专用于匹配子类类型。   
4. 各种通知都可以通过JoinPoint对象获取原方法的调用参数，必须设置为第一个形参，返回后通知和抛出异常后通知可以通过设置returning形参和throwing形参接收对应的返回值和异常对象，环绕通知可以通过手写原方法调用接受返回值和异常对象。

事务：
1. 基本使用流程是在业务层接口上通过@Transactional注解添加Spring事务管理，再根据实现技术设置事务管理器，最后开启注解式事务驱动。
2. 事务传播行为就是事务协调员对事务管理员所携带事务的处理态度。可以设置多个事务协调员对于事务管理员是否开启事务所作出的响应，如是加入管理员事务还是新开一个事务。

### 8.5学习
Spring MVC：
1. 基本使用流程需先导入SpringMVC坐标与Servlet坐标，创建SpringMVC控制类（等同于Servlet功能），配置SpringMVC环境，设定SpringMVC加载对应的Bean，然后初始化Servlet容器加载SpringMVC环境，设置通过SpringMVC技术处理的请求即请求拦截路径。
2. SpringMVC在启动时通常会构建两套上下文，**Root ApplicationContext**和**DispatcherServlet**的上下文，如果不对业务层和控制器隔离处理，Controller 会被两个上下文都加载，导致实例重复、配置冲突、AOP、拦截器、生效环境不一致等问题。  
可以通过对ComponetScan注解进行调整，即只扫描需要的包或扫描所有的包并排除Controller包实现分层。
3. Param支持五种类型的参数传递。普通参数，请求参数与形参名相同可以自动映射；Pojo类其属性和形参名对以上也可以自动映射，Pojo参数还可以嵌套Pojo参数；数组和集合类似，集合要在前加上@RequestParam注解以绑定参数关系。  
Body支持三种json数据的传递。数组使用[...]直接进行传递，Pojo使用{...}内部字段就代表着对象属性，Pojo集合则是使用{}嵌套进行传递。

### 8.6学习
异常处理器：
1. 定义异常处理类，主要是在类上使用<strong>@RestControllerAdvice注解</strong>，定义处理异常逻辑的doException方法并使用<strong>@ExceptionHandler</strong>指定要处理的异常类型。
2. 自定义异常类主要通过拓展**RuntimeException**类实现，内有多个构造方法，按需取用即可。

拦截器：
1. 是SpringMVC中动态拦截控制器方法执行的。可阻止原方法调用，也可用于转为执行预设代码。
2. 和过滤器Filter的区别在于Filter属于Servlet技术，拦截器Interceptor属于SpringMVC技术。Filter是对所有访问进行增强，而Interceptor只对MVC访问进行增强。  
3. 拦截器实现是通过实现**HandlerInterceptor**接口，再在配置类中注册拦截器，配置类通过实现**WebMvcConfigurer**类完成拦截器的注册（**SpringBoot无法简化该配置类**）。
4. 拦截器主要经历preHandle -> controller -> postHandle -> afterCompletion四个方法。若是在preHandle中**return false**就代表着请求被拦截，将无法执行接下来的步骤。
5. 当拦截器运行中断时，仅运行配置在前面的拦截器的afterCompletion操作。