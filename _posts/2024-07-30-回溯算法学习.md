---
title: 回溯算法学习
date: 2024-07-19 8:57:00 +0800
categories: [学习, 算法]
tags: [算法]
---
之前已经在二叉树的部分接触到了回溯算法，实际上回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度，递归就要有终止条件，所以必然是一棵高度有限的树。

回溯三部曲：
* 回溯函数模板返回值以及参数：回溯算法中函数返回值一般为void，但回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
* 回溯函数终止条件：什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
* 回溯搜索的遍历过程：回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。 

总体框架为：
```java
public void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合问题
### 组合
问题：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

* 根据逻辑来决定参数：将问题抽象为树形结构，我们从左往右取数，取过的数不再取，发现n相当于树的宽度，k相当于树的深度，搜索到叶子节点便找到了一个结果，参数就可以是n、k、startIndex即从左往右取的第一个数。此外我们还定义全局变量res和path便于返回结果和回溯。  
* 终止条件：path如果大小为k，就说明到了叶子节点了，这是将path加入到res中就得到了结果之一。  
* 搜索过程：for循环进行横向遍历，递归进行纵向遍历，for循环每次从startIndex开始遍历，然后用path保存取到的节点i，递归往深处遍历，直到找到叶子节点。  

本题还遇到了一个奇怪的问题，我直接result.add(path)是无法正常接收数据的，返回的结果数组全都没有元素，必须得new一个新对象才行。经查证仍然是引用传递的老问题，我们直接将path添加进去的话，path的修改会同时影响到result，之所以最后的结果全为空正是因为path回溯的最终状态就是空。

代码示例：
```java
class Solution {
    List<List<Integer>> result= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }

    public void backtracking(int n,int k,int startIndex){
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i =startIndex;i<=n;i++){
            path.add(i);
            backtracking(n,k,i+1);
            path.removeLast();
        }
    }
}
```
回溯离不开的就是剪枝操作，我们可以剪去可以百分百保证不会再有任何意义的树的遍历来改进性能。

可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。对于本题，如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没有必要搜索了。

修改部分：
```java
// 优化的地方
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { 
    ......    
}
```

### 组合总和III
问题：找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：只使用数字1到9；每个数字最多使用一次 

这一题和上面一题比较相似，很适合进行举一反三，再次不过多赘述。

代码示例：
```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    List<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(k, n, 1);
        return res;
    }
    public void backtracking(int k, int n, int startIndex) {
        if(n < 0) // 剪枝
            return ;
        if(path.size() == k && n == 0) { 
            res.add(new LinkedList(path)); 
            return ;
        }
        for(int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) { // 剪枝
            path.add(i);
            backtracking(k, n - i, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

### 电话号码的字母组合
问题：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

题意就是九键输入法中数字对应字母进行组合，做好数字和字母的映射，依然是回溯三部曲：
* 确定回溯方法参数：本题以单个数字对应字符串作为宽度，数字个数作为深度，可看作树形结构，需要一个index标记深度即进行到哪个数字了
* 确定终止条件：index等于数字字符串长度的时候就终止了。
* 单层遍历逻辑：取index指向的数字，找到其对应的字符集，然后用for循环处理这个字符集。

代码示例：
```java
class Solution {
    String[] numString = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
    List <String> res= new LinkedList<>();
    StringBuilder temp = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return res;
        }
        backTracking(digits, 0);
        return res; 
    }
    public void backTracking(String digits, int index) {
        //遍历全部一次记录一次得到的字符串
        if (index == digits.length()) {
            res.add(temp.toString());
            return;
        }
        //str 表示当前num对应的字符串
        String str = numString[digits.charAt(index) - '0'];
        for (int i = 0; i < str.length(); i++) {
            temp.append(str.charAt(i));
            //递归，处理下一层
            backTracking(digits, index + 1);
            //剔除末尾的继续尝试
            temp.deleteCharAt(temp.length() - 1);
        }
    }
}
```