---
title: 动态规划算法学习
date: 2024-08-14 9:24:00 +0800
categories: [学习, 算法]
tags: [算法]
---

动态规划五部曲：
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了；如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

## 动态规划基础
### 不同路径
问题：一个机器人位于一个 m x n 网格的左上角机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角）。问总共有多少条不同的路径？ 

动规五部曲来分析：
1. 确定dp数组（dp table）以及下标的含义：dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
2. 想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。
3. 如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。
4. 这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。
5. 模拟推导

这题主要是初始化的方面卡住了，不够灵活变通。

代码示例：
```java
class Solution {
    public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        //初始化
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 整数拆分
问题：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

动规五部曲来分析：
1. 确定dp数组（dp table）以及下标的含义：dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
2. 确定递推公式：可以从1遍历j，然后有两种渠道得到dp[i]，一个是j * (i - j) 直接相乘，一个是j * dp[i - j]，相当于是拆分(i - j)，dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))。可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘，如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了，取遍历过程最大的dp[i]。
3. 只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，dp[0]dp[1]无实际意义。
4. dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。下标从小到大
5. 举例推导dp数组。

这题卡在不知道该如何用动态规划处理多种拆分方式，学习到了通过dp[i - j] * j来拆分的方式。

代码示例：
```java
class Solution {
    public int integerBreak(int n) {
        //dp[i] 为正整数 i 拆分后的结果的最大乘积
        int[] dp = new int[n+1];
        dp[2] = 1;
        for(int i = 3; i <= n; i++) {
            for(int j = 1; j <= i-j; j++) {
                // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，
                //并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，
                //j 最大到 i-j,就不会用到 dp[0]与dp[1]
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
                // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘
                //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。
            }
        }
        return dp[n];
    }
}
```

### 不同的二叉搜索树
问题：给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

这题关注一下递推公式的推导就行了，也就是新加入的节点的左子树的种类*右子树的种类，dp[i] += dp[j - 1] * dp[i - j]

代码示例：
```java
class Solution {
    public int numTrees(int n) {
        //初始化 dp 数组
        int[] dp = new int[n + 1];
        //初始化0个节点和1个节点的情况
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
                //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```