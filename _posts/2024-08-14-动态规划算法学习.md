---
title: 动态规划算法学习
date: 2024-08-14 9:24:00 +0800
categories: [学习, 算法]
tags: [算法]
---

动态规划五部曲：
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了；如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

## 动态规划基础
### 不同路径
问题：一个机器人位于一个 m x n 网格的左上角机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角）。问总共有多少条不同的路径？ 

动规五部曲来分析：
1. 确定dp数组（dp table）以及下标的含义：dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
2. 想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。
3. 如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。
4. 这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。
5. 模拟推导

这题主要是初始化的方面卡住了，不够灵活变通。

代码示例：
```java
class Solution {
    public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        //初始化
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 整数拆分
问题：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

动规五部曲来分析：
1. 确定dp数组（dp table）以及下标的含义：dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
2. 确定递推公式：可以从1遍历j，然后有两种渠道得到dp[i]，一个是j * (i - j) 直接相乘，一个是j * dp[i - j]，相当于是拆分(i - j)，dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))。可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘，如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了，取遍历过程最大的dp[i]。
3. 只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，dp[0]dp[1]无实际意义。
4. dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。下标从小到大
5. 举例推导dp数组。

这题卡在不知道该如何用动态规划处理多种拆分方式，学习到了通过dp[i - j] * j来拆分的方式。

代码示例：
```java
class Solution {
    public int integerBreak(int n) {
        //dp[i] 为正整数 i 拆分后的结果的最大乘积
        int[] dp = new int[n+1];
        dp[2] = 1;
        for(int i = 3; i <= n; i++) {
            for(int j = 1; j <= i-j; j++) {
                // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，
                //并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，
                //j 最大到 i-j,就不会用到 dp[0]与dp[1]
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
                // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘
                //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。
            }
        }
        return dp[n];
    }
}
```

### 不同的二叉搜索树
问题：给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

这题关注一下递推公式的推导就行了，也就是新加入的节点的左子树的种类*右子树的种类，dp[i] += dp[j - 1] * dp[i - j]

代码示例：
```java
class Solution {
    public int numTrees(int n) {
        //初始化 dp 数组
        int[] dp = new int[n + 1];
        //初始化0个节点和1个节点的情况
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
                //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```

## 背包问题
### 01背包
#### 01背包理论基础
问题：有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

动规五部曲分析：  
1. 确定dp数组以及下标的含义：需要用到二维数组，有两个维度需要表示，分别是：物品 和 背包容量。我们用二维数组dp[i][j]，i来表示物品、j表示背包容量，dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
2. 递推公式：两种情况，对于新的dp来讲，涉及到要不要把对应物品放入。  
不放物品则由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。  
放入物品则还要考虑价值是否最高，由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值。
3. 初始化：如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0；状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。
4. 遍历顺序：其实都可以，遍历物品更好理解一些。
5. 举例推导。

代码示例：
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // 处理输入
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int[] costs = new int[m];
        int[] values = new int[m];
        for (int i = 0; i < m; i++) {
            costs[i] = sc.nextInt();
        }
        for (int j = 0; j < m; j++) {
            values[j] = sc.nextInt();
        }
        // 调用方法输出
        System.out.println(MaxValue(costs, values, n));
    }
    
    public static int MaxValue(int[] costs, int[] values, int n) {
        // 取第0-i个物品，占据j空间时的最大价值
        int[][] dp = new int[costs.length][n+1];
        // 初始化
        for (int j = costs[0]; j <= n; j++) {
            dp[0][j] = values[0];
        }
        // 递推过程
        for(int i = 1; i < costs.length; i++) {
            for(int j = 0; j <= n; j++) {
                if (j < costs[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - costs[i]] + values[i]);
                }
            }
        }
        // 返回结果
        return dp[costs.length-1][n];
    }
}
```

#### 01背包理论基础（滚动数组）
问题：仍然是上面的问题。

运用滚动数组实现对dp数组的降维。  
递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])，从中其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 直接去掉i这个维度，递推公式就变成了dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

除此之外，一维dp在遍历时需要倒序遍历，是为了保证物品i只被放入一次！

代码示例：
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // 处理输入
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int[] costs = new int[m];
        int[] values = new int[m];
        for (int i = 0; i < m; i++) {
            costs[i] = sc.nextInt();
        }
        for (int j = 0; j < m; j++) {
            values[j] = sc.nextInt();
        }
        // 调用方法输出
        System.out.println(MaxValue(costs, values, n));
    }
    // 处理方法
    public static int MaxValue(int[] costs, int[] values, int n) {
        // 占据j空间时的最大价值
        int[] dp = new int[n+1];
        // 递推过程
        for(int i = 0; i < costs.length; i++) {
            for(int j = n; j >= costs[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
            }
        }
        // 返回结果
        return dp[n];
    }
}
```

#### 分割等和子集
问题：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

本题的目标可以转化为集合里能否出现总和为 sum / 2 的子集，本题中每一个元素的数值既是重量，也是价值，只有确定了如下四点，才能把01背包问题套到本题上来：
* 背包的体积为sum / 2
* 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
* 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
* 背包中每一个元素是不可重复放入。

如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。

动规五部曲：
1. 确定dp数组以及下标的含义：
dp[j]表示容量为j的背包，所背的物品价值最大可以为dp[j]，套到本题，dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]。
1. 递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
2. 题目给的价值都是正整数那么非0下标都初始化为0就可以了。
3. 如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！
4. 举例推导

代码示例：
```java
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        int n = nums.length;
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < n; i++) {
            for(int j = target; j >= nums[i]; j--) {
                //物品 i 的重量是 nums[i]，其价值也是 nums[i]
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
           
            //剪枝一下，每一次完成內層的for-loop，立即檢查是否dp[target] == target，優化時間複雜度（26ms -> 20ms）
            if(dp[target] == target)
                return true;
        }
        return dp[target] == target;
    }
}
```

### 完全背包
#### 完全背包理论基础
问题：和01背包的区别就是，同一个物品可以被重复选择。

01背包和完全背包唯一不同就是体现在遍历顺序上，所以就不去做动规五部曲了，我们直接针对遍历顺序经行分析！既然之前01背包为了不重放选择了使用倒序遍历，那对于完全背包问题，我们正序遍历即可。

代码示例：
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int V = sc.nextInt();
        int[] costs = new int[N];
        int[] values = new int[N];
        for(int i = 0; i < N; i++) {
            costs[i] = sc.nextInt();
            values[i] = sc.nextInt();
        }
        System.out.println(MaxValue(costs, values, N, V));
    }
    public static int MaxValue(int[] costs, int[] values, int N, int V) {
        int[] dp = new int[V + 1];
        for(int i = 0; i < N; i++) {
            for(int j = costs[i]; j <= V; j++)
                dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]);
        }
        return dp[V];
    }
}
```

#### 零钱兑换II
问题：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

递推公式：求装满背包有几种方法，公式都是：dp[j] += dp[j - nums[i]];

此外，纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，故遍历顺序对结果没有影响。但这题，是要求凑成总和的组合数，外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况，这种遍历顺序中dp[j]里计算的是组合数；交换顺序计算的就是排列数。

代码示例：
```java
class Solution {
    public int change(int amount, int[] coins) {
        //递推表达式
        int[] dp = new int[amount + 1];
        //初始化dp数组，表示金额为0时只有一种情况，也就是什么都不装
        dp[0] = 1;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```