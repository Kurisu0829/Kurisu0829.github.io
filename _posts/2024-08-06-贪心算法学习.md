---
title: 贪心算法学习
date: 2024-08-06 11:50:00 +0800
categories: [学习, 算法]
tags: [算法]
---

贪心算法并没有固定的套路。所以唯一的难点就是如何通过局部最优，推出整体最优。体感就是贪心算法挺看感觉的，十分取巧，多做多练才能在遇到难题的时候想到比较好的策略，此外大多数贪心的题目往往可以通过动态规划来解决，动态规划还是作为重点内容，贪心算法就不把遇到的所有题目都记录下来了。

### 摆动序列
问题：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)  是正负交替出现的。相反, [1,4,7,2,5]  和  [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

我们只考虑坡的极点，即减去左值为正减去右值为负，或者减去右值为负而左值为正的元素。需要考虑左右端点、上下坡中有平坡、单调坡度有平坡三种情况，可以综合为(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)这样的条件，并对preDiff在坡度变化时进行实时更新。

除此之外本题还可以用DP来解决，等学习到这里时再来回顾。贪心算法说实话我感觉比较难考虑全面。

代码示例：
```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            //得到当前差值
            curDiff = nums[i] - nums[i - 1];
            //如果当前差值和上一个差值为一正一负
            //等于0的情况表示初始时的preDiff
            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```

### 