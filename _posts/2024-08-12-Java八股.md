---
title: Java八股
date: 2024-08-12 16:43:00 +0800
categories: [学习, 八股]
tags: [八股]
---

## 一. String、StringBuffer、StringBuilder 的区别？
1. 首先，String是不可变的，StringBuffer、StringBuilder是可变的。  
* String类中保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法，同时String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。  
* StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。
2. String 中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。
3. 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer和StringBuilder每次都是对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

## 二. 接口和抽象类的区别
1. 接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。
2. 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
3. 一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。
4. 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（private, protected, public），可以在子类中被重新定义或赋值。
5. Java 8 之前，接口中的方法默认是 public abstract ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 自 Java 9 起，接口可以包含 private 方法。  
抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。

## 三. Java常见的异常类
1. 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:Exception和Error。
2. Exception是指程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
3. 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常。RuntimeException 及其子类都统称为非受检查异常，常见的有NullPointerException；IllegalArgumentException(参数错误比如方法入参类型错误)；NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）；ArrayIndexOutOfBoundsException；ClassCastException（类型转换错误）；ArithmeticException（算术错误）；SecurityException （安全错误比如权限不够）；UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)
4. Error 属于程序无法处理的错误，这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

## 四. 面向对象三大特性
1. 封装：  
* 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。
2. 继承：  
* 继承是使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。  
* 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。子类可以拥有自己属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。
3. 多态：  
* 表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。  
* 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；多态不能调用“只在子类存在但在父类不存在”的方法；如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。

## 五. 重写和重载的区别
1. 重载：  
* 重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。
2. 重写：  
* 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。  
* 其方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明；构造方法无法被重写。  
* 总的来讲，遵循“两同两小一大”的规则，“两同”即方法名相同、形参列表相同；“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

## 六、final关键字有什么作用

## 七、Java中==和equals()的区别
1. == 对于基本类型和引用类型的作用效果是不同的：对于基本数据类型来说，== 比较的是值，而对于引用数据类型来说，== 比较的是对象的内存地址。
2. equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。
3. Object类中的equals()方法是比较的对象的内存地址，等价于==；String 中的 equals 方法是被重写过的，比较的是对象的值。
4. 这里还需要提一下hashCode，哈希码的作用是确定该对象在哈希表中的索引位置，其同样也是用于比较两个对象是否相等的，在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高。
5. 需要注意的是，两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞），两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。所以重写equals()时必须重写hashCode()方法。

## 八、Java的集合类有哪些，哪些线程安全，哪些不安全
1. Java集合均由两大接口派生而来，一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 、Queue。
2. List存储的元素是有序的、可重复的。下有ArrayList，底层为Object[] 数组；Vector，底层为Object[] 数组；LinkedList，底层为双向链表。
3. Set存储的元素不可重复的。下有HashSet，底层采用 HashMap 来保存元素，元素无序唯一；LinkedHashSet，HashSet 的子类，内部是通过 LinkedHashMap 来实现的；TreeSet，底层为红黑树，元素有序唯一。
4. Queue按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。下有PriorityQueue，使用Object[] 数组来实现小顶堆；DelayQueue通过PriorityQueue实现；ArrayDeque使用可扩容动态双向数组实现。
5. Map使用键值对（key-value）存储，下有HashMap，JDK1.8 之前 HashMap 由数组+链表组成的，之后当链表长度大于阈值会转换为红黑树；LinkedHashMap，继承自HashMap，在其基础上增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序；Hashtable，数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的；TreeMap底层为红黑树。
6. 上述集合除了Vector、DelayQueue均不线程安全
7. 非线程安全的集合基本有对应的并发集合类例如 ConcurrentHashMap、CopyOnWriteArrayList、BlockingQueue。
## 九、ArrayList和Array有什么区别？ArrayList和LinkedList有什么区别？
### ArrayList和Array
1. ArrayList会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。
2. ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。
3. ArrayList 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。Array 可以直接存储基本类型数据，也可以存储对象。
4. ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法。
5. ArrayList创建时不需要指定大小，而Array创建时必须指定大小。

### ArrayList和LinkedList
1. ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 。
2. LinkedList 不支持高效的随机元素访问，而 ArrayList支持。
3. ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间。

## 十、ArrayList的扩容机制
1. 以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 
2. 具体过程（以无参构造方法为例）：
* 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0，执行了 ensureCapacityInternal() 方法，minCapacity 此时为 10。此时，minCapacity - elementData.length > 0成立，所以会进入 grow(minCapacity) 方法。
* 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length > 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。
* 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。
* 直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。
3. 总的来说，超过容量之后ArrayList 每次扩容之后容量都会变为原来的 1.5 倍，如果是奇数的话会丢掉小数。

补充知识：Java 中的 length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性；Java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法；Java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看。

## 十一、HashMap及其底层实现
1. HashMap是存储键值对的一种集合，是非线程安全的；可以存储 null 的 key 和 value；初始化大小为 16，之后每次扩充，容量变为原来的 2 倍；若指定大小，扩容时会将其扩充为 2 的幂次方大小；HashMap还对哈希值进行了高位和低位的混合扰动处理以减少冲突。
2. JDK1.8之前底层为数组+链表，之后链表还会转换为红黑树。其中，链表和红黑树是为了解决哈希冲突问题而存在的，遇到哈希冲突，则将冲突的值加到对应索引的链表中即可，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。
3. HashMap的Hash值的范围值-2147483648 到 2147483647，一个 40 亿长度的数组，内存是放不下的，HashMap会取余作为要存放的位置，而取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作，采用二进制位操作 & 相对于 % 能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。