---
title: 认识微服务
date: 2025-08-11 14:56:00 +0800
categories: [学习, 技术]
tags: [技术]
---

## Docker
### 环境配置与基本了解
Docker方面自己以前在部署AutoBangumi这个项目的时候接触过，也是在文档和朋友的帮助下成功的跑了起来，只知道按照他给的配置文件和命令一顿操作，对其是知其然而不知其所以然，为此需要进行更加系统的学习。  
首先是了解了Docker最基本的三元素——**镜像、容器、仓库**，Docker本身只是一个容器的运行载体，而镜像是容器的模板，容器示例由Docker通过镜像文件创建，一个容器运行一种服务，一个镜像可以包含多个容器，仓库则是存放各种镜像的地方。  
我在WSL上配置了阿里云镜像站的stable仓库，安装好了docker-ce，在docker run hello-world时遇到了**context deadline exceeded**报错的问题，总之就是镜像拉不下来，想起来早在去年六七月份国内的docker容器镜像站停用曾引起过一阵讨论，包括阿里云容器仓库的加速器也已经只对云服务器用户开放使用了，我打算用在WSL中配置网络代理的方式来解决。  
了解到Clash For Windows也可以在Linux上运行，我尝试了在WSL上装CFW，配完后发现图形界面并不像Windows上的有系统代理按钮，改用Clash的Linux版本，发现还是不行，在网上搜索相关经验知道了WSL和主机网络是互通的，但由于NAT我们的代理IP配127.0.0.1是不会有效果的，直接配置本机IP即可，最后成功连上代理后却发现命令行仍然是走不了代理的，在<strong>/etc/docker/daemon.json</strong>中配置代理IP后终于成功拉取下来了run hello-world所需的镜像。  

### 镜像常用命令
```
// 列出本地主机上的镜像
docker images -a:列出本地所有镜像（包括历史映像层） -q:只显示镜像ID
// 远程库查找镜像
docker search 镜像名 --limit N:只列出N个镜像，默认25个
// 下载镜像
docker pull 镜像名[:TAG] 没有TAG默认最新版本，等价于:latest
// 查看镜像/容器/数据卷所占的空间
docker system df
// 删除镜像
docker rmi -f:强制删除 镜像ID或镜像名
docker rmi -f 镜像名1:TAG 镜像名2:TAG ... 删除多个
docker rmi -f ${docker images -qa} 删除全部
```

### 容器常用命令  
```
// 新建+启动容器
docker run [OPTIONS] IMAGE [COMMAND][ARG...]
例：docker run -it --name=myMysql mysql bash
// 常用OPTIONS
--name:为容器指定一个名称 -i:交互模式运行容器 -t:为容器重新分配一个伪输入终端，一般-it联合使用 -P:随机分配端口映射 -p:指定端口映射

// 列出所有容器
docker ps -a:列出当前正在运行的和历史上运行过的容器 -l:显示最近创建的容器 -n:显示最近n个创建的容器 -q:只显示容器编号

// 退出容器
exit:容器会停止 ctrl+p+q:容器不停止
// 启动容器
docker start 容器ID或容器名
// 重启容器
docker restart 容器ID或容器名
// 停止容器
docker stop 容器ID或容器名
// 强制停止容器
docker kill 容器ID或容器名
// 删除已停止的容器
docker rm 容器ID
docker rm -f ${docker ps -a -q} 删除所有容器
docker ps -a -q | xargs docker rm 删除所有容器

// 启动守护式容器
docker run -d 容器名 有一些容器如ubuntu后台运行必须有一个前台进程

// 查看容器日志
docker logs 容器ID或容器名
// 查看容器内运行进程
docker top 容器ID或容器名
// 查看容器内部细节
docker inspect 容器ID或容器名

// 重新进入正在运行的容器
docker exec -it 容器ID bash 在容器中打开新的终端，并且可以启动新的进程，exit不会导致容器的停止，推荐使用
docker attach 容器ID 直接进入容器启动命令的终端，不会启动新的进程，exit会导致容器的停止

// 容器内文件拷贝
docker cp 容器ID:容器内路径 目的主机路径
// 容器导出
docker export 容器ID > tar文件名
// 容器导入
cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号
```

### 镜像进阶  
镜像：  
Docker中镜像是从base镜像一层一层叠加生成的。当容器启动时，一个新的可写层将被加载到镜像的顶部，这一层通常被称为容器层，容器层之下的都叫镜像层，所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。  
Docker Hub中拉取的Ubuntu镜像是轻量级的，只包含了必要核心功能，以vim为例，是不支持该命令的。我们在拉取的镜像中安装vim，再通过<strong>docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[tag]</strong>命令生成新的镜像，那么这个镜像就相当于是升级版的Ubuntu了。  
镜像上传阿里云在阿里云官网有一套完整的命令和说明，后续个人项目的环境就打算配置一套在阿里云上，对于私有库的搭建主要是了解相关的使用方法和常规配置仓库有没有什么区别，因为后续在工作中接触的Docker相关大概也是自建私有库进行存储的。  

数据卷：  
卷就是目录或者文件，容器数据卷就是将容器目录和主机目录做映射，将容器中的重要数据备份+持久化到本地主机目录。数据卷能够绕过Union File System提供一些持续存储或共享数据的特性，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。  
要给运行的容器挂载数据卷，需要通过<strong>--privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名</strong>这样的OPTIONS来挂载。加上ro的话容器自己只能读不能写，但宿主机的修改可以同步到容器。  
Docker中服务安装基本就是拉取镜像并运行容器的过程，但之中会出现例如tomcat目录下webapps为空，而运行所需实际内容变更到了webapps.list文件夹这中问题，需要我们手动进行修改。  
而Mysql安装出现的问题就是Docker上默认字符集编码不支持我们对中文数据进行操作，且若是要对Mysql容器进行删除，我们在实际运行容器时要挂载<strong>/log、/data、/conf</strong>的容器数据卷以保证数据不丢失。挂载好后在/conf下创建my.cnf配置UTF8字符集后即可正常处理中文数据。Redis容器同样也面临着这样的问题，因此要挂载数据卷后配置redis.conf。  
```
// mysql安装过程，以mysql5.7为例
docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 常规安装
docker run -d -p 3306:3306 --privileged=true -v /home/kurisu/mysql/log:/var/log/mysql -v /home/kurisu/mysql/data:/var/lib/mysql -v /home/kurisu/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7 挂载数据卷安装

// 在conf/my.cnf下新增内容解决中文数据无法操作的问题，并开启自动补全
[client]
default-character-set = utf8
[mysqld]
collation_server = utf8_general_ci
character-set-server = utf8
[mysql]
auto-rehash

// Redis安装过程
首先在宿主机上拷贝一份redis.conf模板
修改该模板，注释掉bind 127.0.0.1允许外网连接，修改daemonize yes为daemonize no
// 挂载数据卷，读取宿主机上修改好的配置文件启动
docker run -p 6379:6379 -privileged=true -v /home/kurisu/redis/redis.conf:/etc/redis/redis.conf -v /home/kurisu/redis/data:/data -d redis:6.0.8 --name redis redis-server /etc/redis/redis.conf
```

### _Dockerfile简介
Dockerfile是用来构建镜像的文本文件，由一条条构建镜像所需的指令合参数构成的脚本组成。Dockerfile将镜像逐步增强反复commit的过程列清单一次性搞定，通过编写Dockerfile文件、docker build命令构建镜像、docker run运行镜像三步完成一个完整的镜像安装运行过程。  
Dockerfile中每条保留字指令都必须**大写字母**并后面跟随至少一个参数，指令从上往下依次顺序执行，用#表示注释，每条指令都会创建一个新镜像层并提交。大致流程是Docker从基础镜像运行一个容器，执行一条指令并对容器做修改，执行类似docker commit的操作提交一个新的镜像层，docker再基于刚提交的镜像运行一个新容器，执行dockerfile中的下一条指令重复直至所有指令完成。

### _Dockerfile保留字
```dockerfile
FROM # 基础镜像，指定一个已存在的镜像作为模板，第一条必须是FROM
MAINTAINER # 镜像维护者的姓名和邮箱地址

RUN apt install ... # 构建时要执行的命令，等同于终端中操作的Shell命令，此为shell格式写法
RUN["可执行文件", "参数1", "参数2"] # 例如RUN["./test.php", "dev", "offline"]等价于RUN ./test.php dev offline，此为exec格式写法

EXPOSE # 当前容器对外暴露出的端口
WORKDIR # 指定在创建容器后，终端默认登陆的工作目录
USER # 指定镜像该以什么用户去运行，默认root
ENV # 配置运行时环境变量，如ENV MY_PATH /usr/mytest，后续指令可直接引用$MY_PATH。
VOLUME # 容器数据卷，用于数据保存和持久化工作

ADD # 将宿主机下的文件拷贝进镜像且自动处理URL和解压tar压缩包
COPY # 类似ADD，拷贝文件和目录到镜像中，从源路径复制复制到新的一层镜像中的目标路径中

CMD # 指定容器启动后要做的事，格式和RUN相似，注意只有最后一个会生效，且CMD会被docker run之后的参数替换
ENTRYPOINT # 也是用来指定一个容器启动要运行的命令，类似于CMD指令，但不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数传入ENTRYPOINT指定的程序
# ENTRYPOINT可以和CMD一起使用，一般是变参使用CMD，这里的CMD等于是在给ENTRYPOINT传参，两个命令组合会变成<ENTRYPOINT>"<CMD>"

```